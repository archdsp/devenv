;; Object semanticdb-project-database-file
;; SEMANTICDB Tags save file
(semanticdb-project-database-file "semanticdb-project-database-file"
  :tables
  (list
    (semanticdb-table "semanticdb-table"
      :major-mode python-mode
      :tags 
        '( ("__future__" include nil nil [1443 1507])
            ("math" include nil nil [1509 1520])
            ("numpy" include nil nil [1521 1533])
            ("_ni_support" include nil nil [1541 1559])
            ("_nd_image" include nil nil [1567 1583])
            ("scipy.misc" include nil nil [1584 1613])
            ("scipy._lib._version" include nil nil [1614 1658])
            ("__all__" variable nil nil [1660 2177])
            ("_input_doc" variable nil nil [2180 2246])
            ("_axis_doc" variable nil nil [2247 2352])
            ("_output_doc" variable nil nil [2353 2580])
            ("_size_foot_doc" variable nil nil [2581 3304])
            ("_mode_doc" variable nil nil [3305 3554])
            ("_mode_multiple_doc" variable nil nil [3555 3976])
            ("_cval_doc" variable nil nil [3977 4102])
            ("_origin_doc" variable nil nil [4103 4232])
            ("_extra_arguments_doc" variable nil nil [4233 4370])
            ("_extra_keywords_doc" variable nil nil [4371 4495])
            ("docdict" variable nil nil [4497 4824])
            ("docfiller" variable nil nil [4826 4861])
            ("correlate1d" function
               (:documentation "Calculate a one-dimensional correlation along the given axis.

    The lines of the array along the given axis are correlated with the
    given weights.

    Parameters
    ----------
    %(input)s
    weights : array
        One-dimensional sequence of numbers.
    %(axis)s
    %(output)s
    %(mode)s
    %(cval)s
    %(origin)s

    Examples
    --------
    >>> from scipy.ndimage import correlate1d
    >>> correlate1d([2, 8, 0, 4, 1, 9, 9, 0], weights=[1, 3])
    array([ 8, 26,  8, 12,  7, 28, 36,  9])
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [4891 4896])
                    ("weights" variable nil (reparse-symbol function_parameters) [4898 4905])
                    ("axis" variable nil (reparse-symbol function_parameters) [4907 4911])
                    ("output" variable nil (reparse-symbol function_parameters) [4916 4922])
                    ("mode" variable nil (reparse-symbol function_parameters) [4929 4933])
                    ("cval" variable nil (reparse-symbol function_parameters) [4961 4965])
                    ("origin" variable nil (reparse-symbol function_parameters) [4971 4977]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [4864 6332])
            ("convolve1d" function
               (:documentation "Calculate a one-dimensional convolution along the given axis.

    The lines of the array along the given axis are convolved with the
    given weights.

    Parameters
    ----------
    %(input)s
    weights : ndarray
        One-dimensional sequence of numbers.
    %(axis)s
    %(output)s
    %(mode)s
    %(cval)s
    %(origin)s

    Returns
    -------
    convolve1d : ndarray
        Convolved array with same shape as input

    Examples
    --------
    >>> from scipy.ndimage import convolve1d
    >>> convolve1d([2, 8, 0, 4, 1, 9, 9, 0], weights=[1, 3])
    array([14, 24,  4, 13, 12, 36, 27,  0])
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [6360 6365])
                    ("weights" variable nil (reparse-symbol function_parameters) [6367 6374])
                    ("axis" variable nil (reparse-symbol function_parameters) [6376 6380])
                    ("output" variable nil (reparse-symbol function_parameters) [6385 6391])
                    ("mode" variable nil (reparse-symbol function_parameters) [6398 6402])
                    ("cval" variable nil (reparse-symbol function_parameters) [6429 6433])
                    ("origin" variable nil (reparse-symbol function_parameters) [6439 6445]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [6334 7246])
            ("_gaussian_kernel1d" function
               (:documentation "
    Computes a 1D Gaussian convolution kernel.
    "
                :arguments 
                  ( ("sigma" variable nil (reparse-symbol function_parameters) [7271 7276])
                    ("order" variable nil (reparse-symbol function_parameters) [7278 7283])
                    ("radius" variable nil (reparse-symbol function_parameters) [7285 7291]))                  )
                nil [7248 7922])
            ("gaussian_filter1d" function
               (:documentation "One-dimensional Gaussian filter.

    Parameters
    ----------
    %(input)s
    sigma : scalar
        standard deviation for Gaussian kernel
    %(axis)s
    order : int, optional
        An order of 0 corresponds to convolution with a Gaussian
        kernel. A positive order corresponds to convolution with
        that derivative of a Gaussian.
    %(output)s
    %(mode)s
    %(cval)s
    truncate : float, optional
        Truncate the filter at this many standard deviations.
        Default is 4.0.

    Returns
    -------
    gaussian_filter1d : ndarray

    Examples
    --------
    >>> from scipy.ndimage import gaussian_filter1d
    >>> gaussian_filter1d([1.0, 2.0, 3.0, 4.0, 5.0], 1)
    array([ 1.42704095,  2.06782203,  3.        ,  3.93217797,  4.57295905])
    >>> gaussian_filter1d([1.0, 2.0, 3.0, 4.0, 5.0], 4)
    array([ 2.91948343,  2.95023502,  3.        ,  3.04976498,  3.08051657])
    >>> import matplotlib.pyplot as plt
    >>> np.random.seed(280490)
    >>> x = np.random.randn(101).cumsum()
    >>> y3 = gaussian_filter1d(x, 3)
    >>> y6 = gaussian_filter1d(x, 6)
    >>> plt.plot(x, 'k', label='original data')
    >>> plt.plot(y3, '--', label='filtered, sigma=3')
    >>> plt.plot(y6, ':', label='filtered, sigma=6')
    >>> plt.legend()
    >>> plt.grid()
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [7957 7962])
                    ("sigma" variable nil (reparse-symbol function_parameters) [7964 7969])
                    ("axis" variable nil (reparse-symbol function_parameters) [7971 7975])
                    ("order" variable nil (reparse-symbol function_parameters) [7980 7985])
                    ("output" variable nil (reparse-symbol function_parameters) [7989 7995])
                    ("mode" variable nil (reparse-symbol function_parameters) [8024 8028])
                    ("cval" variable nil (reparse-symbol function_parameters) [8040 8044])
                    ("truncate" variable nil (reparse-symbol function_parameters) [8050 8058]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [7924 9718])
            ("gaussian_filter" function
               (:documentation "Multidimensional Gaussian filter.

    Parameters
    ----------
    %(input)s
    sigma : scalar or sequence of scalars
        Standard deviation for Gaussian kernel. The standard
        deviations of the Gaussian filter are given for each axis as a
        sequence, or as a single number, in which case it is equal for
        all axes.
    order : int or sequence of ints, optional
        The order of the filter along each axis is given as a sequence
        of integers, or as a single number.  An order of 0 corresponds
        to convolution with a Gaussian kernel. A positive order
        corresponds to convolution with that derivative of a Gaussian.
    %(output)s
    %(mode_multiple)s
    %(cval)s
    truncate : float
        Truncate the filter at this many standard deviations.
        Default is 4.0.

    Returns
    -------
    gaussian_filter : ndarray
        Returned array of same shape as `input`.

    Notes
    -----
    The multidimensional filter is implemented as a sequence of
    one-dimensional convolution filters. The intermediate arrays are
    stored in the same data type as the output. Therefore, for output
    types with a limited precision, the results may be imprecise
    because intermediate results may be stored with insufficient
    precision.

    Examples
    --------
    >>> from scipy.ndimage import gaussian_filter
    >>> a = np.arange(50, step=2).reshape((5,5))
    >>> a
    array([[ 0,  2,  4,  6,  8],
           [10, 12, 14, 16, 18],
           [20, 22, 24, 26, 28],
           [30, 32, 34, 36, 38],
           [40, 42, 44, 46, 48]])
    >>> gaussian_filter(a, sigma=1)
    array([[ 4,  6,  8,  9, 11],
           [10, 12, 14, 15, 17],
           [20, 22, 24, 25, 27],
           [29, 31, 33, 34, 36],
           [35, 37, 39, 40, 42]])

    >>> from scipy import misc
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> plt.gray()  # show the filtered result in grayscale
    >>> ax1 = fig.add_subplot(121)  # left side
    >>> ax2 = fig.add_subplot(122)  # right side
    >>> ascent = misc.ascent()
    >>> result = gaussian_filter(ascent, sigma=5)
    >>> ax1.imshow(ascent)
    >>> ax2.imshow(result)
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [9751 9756])
                    ("sigma" variable nil (reparse-symbol function_parameters) [9758 9763])
                    ("order" variable nil (reparse-symbol function_parameters) [9765 9770])
                    ("output" variable nil (reparse-symbol function_parameters) [9774 9780])
                    ("mode" variable nil (reparse-symbol function_parameters) [9807 9811])
                    ("cval" variable nil (reparse-symbol function_parameters) [9823 9827])
                    ("truncate" variable nil (reparse-symbol function_parameters) [9833 9841]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [9720 12795])
            ("prewitt" function
               (:documentation "Calculate a Prewitt filter.

    Parameters
    ----------
    %(input)s
    %(axis)s
    %(output)s
    %(mode_multiple)s
    %(cval)s

    Examples
    --------
    >>> from scipy import ndimage, misc
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> plt.gray()  # show the filtered result in grayscale
    >>> ax1 = fig.add_subplot(121)  # left side
    >>> ax2 = fig.add_subplot(122)  # right side
    >>> ascent = misc.ascent()
    >>> result = ndimage.prewitt(ascent)
    >>> ax1.imshow(ascent)
    >>> ax2.imshow(result)
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [12820 12825])
                    ("axis" variable nil (reparse-symbol function_parameters) [12827 12831])
                    ("output" variable nil (reparse-symbol function_parameters) [12836 12842])
                    ("mode" variable nil (reparse-symbol function_parameters) [12849 12853])
                    ("cval" variable nil (reparse-symbol function_parameters) [12865 12869]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [12797 13922])
            ("sobel" function
               (:documentation "Calculate a Sobel filter.

    Parameters
    ----------
    %(input)s
    %(axis)s
    %(output)s
    %(mode_multiple)s
    %(cval)s

    Examples
    --------
    >>> from scipy import ndimage, misc
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> plt.gray()  # show the filtered result in grayscale
    >>> ax1 = fig.add_subplot(121)  # left side
    >>> ax2 = fig.add_subplot(122)  # right side
    >>> ascent = misc.ascent()
    >>> result = ndimage.sobel(ascent)
    >>> ax1.imshow(ascent)
    >>> ax2.imshow(result)
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [13945 13950])
                    ("axis" variable nil (reparse-symbol function_parameters) [13952 13956])
                    ("output" variable nil (reparse-symbol function_parameters) [13961 13967])
                    ("mode" variable nil (reparse-symbol function_parameters) [13974 13978])
                    ("cval" variable nil (reparse-symbol function_parameters) [13990 13994]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [13924 15042])
            ("generic_laplace" function
               (:documentation "
    N-dimensional Laplace filter using a provided second derivative function.

    Parameters
    ----------
    %(input)s
    derivative2 : callable
        Callable with the following signature::

            derivative2(input, axis, output, mode, cval,
                        *extra_arguments, **extra_keywords)

        See `extra_arguments`, `extra_keywords` below.
    %(output)s
    %(mode_multiple)s
    %(cval)s
    %(extra_keywords)s
    %(extra_arguments)s
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [15075 15080])
                    ("derivative2" variable nil (reparse-symbol function_parameters) [15082 15093])
                    ("output" variable nil (reparse-symbol function_parameters) [15095 15101])
                    ("mode" variable nil (reparse-symbol function_parameters) [15108 15112])
                    ("cval" variable nil (reparse-symbol function_parameters) [15144 15148])
                    ("extra_arguments" variable nil (reparse-symbol function_parameters) [15174 15189])
                    ("extra_keywords" variable nil (reparse-symbol function_parameters) [15214 15228]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [15044 16393])
            ("laplace" function
               (:documentation "N-dimensional Laplace filter based on approximate second derivatives.

    Parameters
    ----------
    %(input)s
    %(output)s
    %(mode_multiple)s
    %(cval)s

    Examples
    --------
    >>> from scipy import ndimage, misc
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> plt.gray()  # show the filtered result in grayscale
    >>> ax1 = fig.add_subplot(121)  # left side
    >>> ax2 = fig.add_subplot(122)  # right side
    >>> ascent = misc.ascent()
    >>> result = ndimage.laplace(ascent)
    >>> ax1.imshow(ascent)
    >>> ax2.imshow(result)
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [16418 16423])
                    ("output" variable nil (reparse-symbol function_parameters) [16425 16431])
                    ("mode" variable nil (reparse-symbol function_parameters) [16438 16442])
                    ("cval" variable nil (reparse-symbol function_parameters) [16454 16458]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [16395 17277])
            ("gaussian_laplace" function
               (:documentation "Multidimensional Laplace filter using gaussian second derivatives.

    Parameters
    ----------
    %(input)s
    sigma : scalar or sequence of scalars
        The standard deviations of the Gaussian filter are given for
        each axis as a sequence, or as a single number, in which case
        it is equal for all axes.
    %(output)s
    %(mode_multiple)s
    %(cval)s
    Extra keyword arguments will be passed to gaussian_filter().

    Examples
    --------
    >>> from scipy import ndimage, misc
    >>> import matplotlib.pyplot as plt
    >>> ascent = misc.ascent()

    >>> fig = plt.figure()
    >>> plt.gray()  # show the filtered result in grayscale
    >>> ax1 = fig.add_subplot(121)  # left side
    >>> ax2 = fig.add_subplot(122)  # right side

    >>> result = ndimage.gaussian_laplace(ascent, sigma=1)
    >>> ax1.imshow(result)

    >>> result = ndimage.gaussian_laplace(ascent, sigma=3)
    >>> ax2.imshow(result)
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [17311 17316])
                    ("sigma" variable nil (reparse-symbol function_parameters) [17318 17323])
                    ("output" variable nil (reparse-symbol function_parameters) [17325 17331])
                    ("mode" variable nil (reparse-symbol function_parameters) [17338 17342])
                    ("cval" variable nil (reparse-symbol function_parameters) [17375 17379])
                    ("kwargs" variable nil (reparse-symbol function_parameters) [17385 17393]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [17279 18815])
            ("generic_gradient_magnitude" function
               (:documentation "Gradient magnitude using a provided gradient function.

    Parameters
    ----------
    %(input)s
    derivative : callable
        Callable with the following signature::

            derivative(input, axis, output, mode, cval,
                       *extra_arguments, **extra_keywords)

        See `extra_arguments`, `extra_keywords` below.
        `derivative` can assume that `input` and `output` are ndarrays.
        Note that the output from `derivative` is modified inplace;
        be careful to copy important inputs before returning them.
    %(output)s
    %(mode_multiple)s
    %(cval)s
    %(extra_keywords)s
    %(extra_arguments)s
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [18859 18864])
                    ("derivative" variable nil (reparse-symbol function_parameters) [18866 18876])
                    ("output" variable nil (reparse-symbol function_parameters) [18878 18884])
                    ("mode" variable nil (reparse-symbol function_parameters) [18922 18926])
                    ("cval" variable nil (reparse-symbol function_parameters) [18938 18942])
                    ("extra_arguments" variable nil (reparse-symbol function_parameters) [18979 18994])
                    ("extra_keywords" variable nil (reparse-symbol function_parameters) [18999 19013]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [18817 20568])
            ("gaussian_gradient_magnitude" function
               (:documentation "Multidimensional gradient magnitude using Gaussian derivatives.

    Parameters
    ----------
    %(input)s
    sigma : scalar or sequence of scalars
        The standard deviations of the Gaussian filter are given for
        each axis as a sequence, or as a single number, in which case
        it is equal for all axes..
    %(output)s
    %(mode_multiple)s
    %(cval)s
    Extra keyword arguments will be passed to gaussian_filter().

    Returns
    -------
    gaussian_gradient_magnitude : ndarray
        Filtered array. Has the same shape as `input`.

    Examples
    --------
    >>> from scipy import ndimage, misc
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> plt.gray()  # show the filtered result in grayscale
    >>> ax1 = fig.add_subplot(121)  # left side
    >>> ax2 = fig.add_subplot(122)  # right side
    >>> ascent = misc.ascent()
    >>> result = ndimage.gaussian_gradient_magnitude(ascent, sigma=5)
    >>> ax1.imshow(ascent)
    >>> ax2.imshow(result)
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [20613 20618])
                    ("sigma" variable nil (reparse-symbol function_parameters) [20620 20625])
                    ("output" variable nil (reparse-symbol function_parameters) [20627 20633])
                    ("mode" variable nil (reparse-symbol function_parameters) [20672 20676])
                    ("cval" variable nil (reparse-symbol function_parameters) [20688 20692])
                    ("kwargs" variable nil (reparse-symbol function_parameters) [20698 20706]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [20570 22228])
            ("_correlate_or_convolve" function (:arguments 
              ( ("input" variable nil (reparse-symbol function_parameters) [22257 22262])
                ("weights" variable nil (reparse-symbol function_parameters) [22264 22271])
                ("output" variable nil (reparse-symbol function_parameters) [22273 22279])
                ("mode" variable nil (reparse-symbol function_parameters) [22281 22285])
                ("cval" variable nil (reparse-symbol function_parameters) [22287 22291])
                ("origin" variable nil (reparse-symbol function_parameters) [22293 22299])
                ("convolution" variable nil (reparse-symbol function_parameters) [22328 22339]))              ) nil [22230 23431])
            ("correlate" function
               (:documentation "
    Multi-dimensional correlation.

    The array is correlated with the given kernel.

    Parameters
    ----------
    input : array-like
        input array to filter
    weights : ndarray
        array of weights, same number of dimensions as input
    output : array, optional
        The ``output`` parameter passes an array in which to store the
        filter output. Output array should have different name as
        compared to input array to avoid aliasing errors.
    mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
        The ``mode`` parameter determines how the array borders are
        handled, where ``cval`` is the value when mode is equal to
        'constant'. Default is 'reflect'
    cval : scalar, optional
        Value to fill past edges of input if ``mode`` is 'constant'. Default
        is 0.0
    origin : scalar, optional
        The ``origin`` parameter controls the placement of the filter.
        Default 0

    See Also
    --------
    convolve : Convolve an image with a kernel.
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [23458 23463])
                    ("weights" variable nil (reparse-symbol function_parameters) [23465 23472])
                    ("output" variable nil (reparse-symbol function_parameters) [23474 23480])
                    ("mode" variable nil (reparse-symbol function_parameters) [23487 23491])
                    ("cval" variable nil (reparse-symbol function_parameters) [23503 23507])
                    ("origin" variable nil (reparse-symbol function_parameters) [23527 23533]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [23433 24712])
            ("convolve" function
               (:documentation "
    Multidimensional convolution.

    The array is convolved with the given kernel.

    Parameters
    ----------
    input : array_like
        Input array to filter.
    weights : array_like
        Array of weights, same number of dimensions as input
    output : ndarray, optional
        The `output` parameter passes an array in which to store the
        filter output. Output array should have different name as
        compared to input array to avoid aliasing errors.
    mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
        the `mode` parameter determines how the array borders are
        handled. For 'constant' mode, values beyond borders are set to be
        `cval`. Default is 'reflect'.
    cval : scalar, optional
        Value to fill past edges of input if `mode` is 'constant'. Default
        is 0.0
    origin : array_like, optional
        The `origin` parameter controls the placement of the filter,
        relative to the centre of the current element of the input.
        Default of 0 is equivalent to ``(0,)*input.ndim``.

    Returns
    -------
    result : ndarray
        The result of convolution of `input` with `weights`.

    See Also
    --------
    correlate : Correlate an image with a kernel.

    Notes
    -----
    Each value in result is :math:`C_i = \\\\sum_j{I_{i+k-j} W_j}`, where
    W is the `weights` kernel,
    j is the n-D spatial index over :math:`W`,
    I is the `input` and k is the coordinate of the center of
    W, specified by `origin` in the input parameters.

    Examples
    --------
    Perhaps the simplest case to understand is ``mode='constant', cval=0.0``,
    because in this case borders (i.e. where the `weights` kernel, centered
    on any one value, extends beyond an edge of `input`.

    >>> a = np.array([[1, 2, 0, 0],
    ...               [5, 3, 0, 4],
    ...               [0, 0, 0, 7],
    ...               [9, 3, 0, 0]])
    >>> k = np.array([[1,1,1],[1,1,0],[1,0,0]])
    >>> from scipy import ndimage
    >>> ndimage.convolve(a, k, mode='constant', cval=0.0)
    array([[11, 10,  7,  4],
           [10,  3, 11, 11],
           [15, 12, 14,  7],
           [12,  3,  7,  0]])

    Setting ``cval=1.0`` is equivalent to padding the outer edge of `input`
    with 1.0's (and then extracting only the original region of the result).

    >>> ndimage.convolve(a, k, mode='constant', cval=1.0)
    array([[13, 11,  8,  7],
           [11,  3, 11, 14],
           [16, 12, 14, 10],
           [15,  6, 10,  5]])

    With ``mode='reflect'`` (the default), outer values are reflected at the
    edge of `input` to fill in missing values.

    >>> b = np.array([[2, 0, 0],
    ...               [1, 0, 0],
    ...               [0, 0, 0]])
    >>> k = np.array([[0,1,0], [0,1,0], [0,1,0]])
    >>> ndimage.convolve(b, k, mode='reflect')
    array([[5, 0, 0],
           [3, 0, 0],
           [1, 0, 0]])

    This includes diagonally at the corners.

    >>> k = np.array([[1,0,0],[0,1,0],[0,0,1]])
    >>> ndimage.convolve(b, k)
    array([[4, 2, 0],
           [3, 2, 0],
           [1, 1, 0]])

    With ``mode='nearest'``, the single nearest value in to an edge in
    `input` is repeated as many times as needed to match the overlapping
    `weights`.

    >>> c = np.array([[2, 0, 1],
    ...               [1, 0, 0],
    ...               [0, 0, 0]])
    >>> k = np.array([[0, 1, 0],
    ...               [0, 1, 0],
    ...               [0, 1, 0],
    ...               [0, 1, 0],
    ...               [0, 1, 0]])
    >>> ndimage.convolve(c, k, mode='nearest')
    array([[7, 0, 3],
           [5, 0, 2],
           [3, 0, 1]])

    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [24738 24743])
                    ("weights" variable nil (reparse-symbol function_parameters) [24745 24752])
                    ("output" variable nil (reparse-symbol function_parameters) [24754 24760])
                    ("mode" variable nil (reparse-symbol function_parameters) [24767 24771])
                    ("cval" variable nil (reparse-symbol function_parameters) [24783 24787])
                    ("origin" variable nil (reparse-symbol function_parameters) [24806 24812]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [24714 28595])
            ("uniform_filter1d" function
               (:documentation "Calculate a one-dimensional uniform filter along the given axis.

    The lines of the array along the given axis are filtered with a
    uniform filter of given size.

    Parameters
    ----------
    %(input)s
    size : int
        length of uniform filter
    %(axis)s
    %(output)s
    %(mode)s
    %(cval)s
    %(origin)s

    Examples
    --------
    >>> from scipy.ndimage import uniform_filter1d
    >>> uniform_filter1d([2, 8, 0, 4, 1, 9, 9, 0], size=3)
    array([4, 3, 4, 1, 4, 6, 6, 3])
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [28629 28634])
                    ("size" variable nil (reparse-symbol function_parameters) [28636 28640])
                    ("axis" variable nil (reparse-symbol function_parameters) [28642 28646])
                    ("output" variable nil (reparse-symbol function_parameters) [28651 28657])
                    ("mode" variable nil (reparse-symbol function_parameters) [28685 28689])
                    ("cval" variable nil (reparse-symbol function_parameters) [28701 28705])
                    ("origin" variable nil (reparse-symbol function_parameters) [28711 28717]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [28597 29840])
            ("uniform_filter" function
               (:documentation "Multi-dimensional uniform filter.

    Parameters
    ----------
    %(input)s
    size : int or sequence of ints, optional
        The sizes of the uniform filter are given for each axis as a
        sequence, or as a single number, in which case the size is
        equal for all axes.
    %(output)s
    %(mode_multiple)s
    %(cval)s
    %(origin)s

    Returns
    -------
    uniform_filter : ndarray
        Filtered array. Has the same shape as `input`.

    Notes
    -----
    The multi-dimensional filter is implemented as a sequence of
    one-dimensional uniform filters. The intermediate arrays are stored
    in the same data type as the output. Therefore, for output types
    with a limited precision, the results may be imprecise because
    intermediate results may be stored with insufficient precision.

    Examples
    --------
    >>> from scipy import ndimage, misc
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> plt.gray()  # show the filtered result in grayscale
    >>> ax1 = fig.add_subplot(121)  # left side
    >>> ax2 = fig.add_subplot(122)  # right side
    >>> ascent = misc.ascent()
    >>> result = ndimage.uniform_filter(ascent, size=20)
    >>> ax1.imshow(ascent)
    >>> ax2.imshow(result)
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [29872 29877])
                    ("size" variable nil (reparse-symbol function_parameters) [29879 29883])
                    ("output" variable nil (reparse-symbol function_parameters) [29887 29893])
                    ("mode" variable nil (reparse-symbol function_parameters) [29900 29904])
                    ("cval" variable nil (reparse-symbol function_parameters) [29935 29939])
                    ("origin" variable nil (reparse-symbol function_parameters) [29945 29951]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [29842 31958])
            ("minimum_filter1d" function
               (:documentation "Calculate a one-dimensional minimum filter along the given axis.

    The lines of the array along the given axis are filtered with a
    minimum filter of given size.

    Parameters
    ----------
    %(input)s
    size : int
        length along which to calculate 1D minimum
    %(axis)s
    %(output)s
    %(mode)s
    %(cval)s
    %(origin)s

    Notes
    -----
    This function implements the MINLIST algorithm [1]_, as described by
    Richard Harter [2]_, and has a guaranteed O(n) performance, `n` being
    the `input` length, regardless of filter size.

    References
    ----------
    .. [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2777
    .. [2] http://www.richardhartersworld.com/cri/2001/slidingmin.html


    Examples
    --------
    >>> from scipy.ndimage import minimum_filter1d
    >>> minimum_filter1d([2, 8, 0, 4, 1, 9, 9, 0], size=3)
    array([2, 0, 0, 0, 1, 1, 0, 0])
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [31992 31997])
                    ("size" variable nil (reparse-symbol function_parameters) [31999 32003])
                    ("axis" variable nil (reparse-symbol function_parameters) [32005 32009])
                    ("output" variable nil (reparse-symbol function_parameters) [32014 32020])
                    ("mode" variable nil (reparse-symbol function_parameters) [32048 32052])
                    ("cval" variable nil (reparse-symbol function_parameters) [32064 32068])
                    ("origin" variable nil (reparse-symbol function_parameters) [32074 32080]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [31960 33627])
            ("maximum_filter1d" function
               (:documentation "Calculate a one-dimensional maximum filter along the given axis.

    The lines of the array along the given axis are filtered with a
    maximum filter of given size.

    Parameters
    ----------
    %(input)s
    size : int
        Length along which to calculate the 1-D maximum.
    %(axis)s
    %(output)s
    %(mode)s
    %(cval)s
    %(origin)s

    Returns
    -------
    maximum1d : ndarray, None
        Maximum-filtered array with same shape as input.
        None if `output` is not None

    Notes
    -----
    This function implements the MAXLIST algorithm [1]_, as described by
    Richard Harter [2]_, and has a guaranteed O(n) performance, `n` being
    the `input` length, regardless of filter size.

    References
    ----------
    .. [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2777
    .. [2] http://www.richardhartersworld.com/cri/2001/slidingmin.html

    Examples
    --------
    >>> from scipy.ndimage import maximum_filter1d
    >>> maximum_filter1d([2, 8, 0, 4, 1, 9, 9, 0], size=3)
    array([8, 8, 8, 4, 9, 9, 9, 9])
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [33661 33666])
                    ("size" variable nil (reparse-symbol function_parameters) [33668 33672])
                    ("axis" variable nil (reparse-symbol function_parameters) [33674 33678])
                    ("output" variable nil (reparse-symbol function_parameters) [33683 33689])
                    ("mode" variable nil (reparse-symbol function_parameters) [33717 33721])
                    ("cval" variable nil (reparse-symbol function_parameters) [33733 33737])
                    ("origin" variable nil (reparse-symbol function_parameters) [33743 33749]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [33629 35450])
            ("_min_or_max_filter" function (:arguments 
              ( ("input" variable nil (reparse-symbol function_parameters) [35475 35480])
                ("size" variable nil (reparse-symbol function_parameters) [35482 35486])
                ("footprint" variable nil (reparse-symbol function_parameters) [35488 35497])
                ("structure" variable nil (reparse-symbol function_parameters) [35499 35508])
                ("output" variable nil (reparse-symbol function_parameters) [35510 35516])
                ("mode" variable nil (reparse-symbol function_parameters) [35518 35522])
                ("cval" variable nil (reparse-symbol function_parameters) [35547 35551])
                ("origin" variable nil (reparse-symbol function_parameters) [35553 35559])
                ("minimum" variable nil (reparse-symbol function_parameters) [35561 35568]))              ) nil [35452 38197])
            ("minimum_filter" function
               (:documentation "Calculate a multi-dimensional minimum filter.

    Parameters
    ----------
    %(input)s
    %(size_foot)s
    %(output)s
    %(mode_multiple)s
    %(cval)s
    %(origin)s

    Returns
    -------
    minimum_filter : ndarray
        Filtered array. Has the same shape as `input`.

    Examples
    --------
    >>> from scipy import ndimage, misc
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> plt.gray()  # show the filtered result in grayscale
    >>> ax1 = fig.add_subplot(121)  # left side
    >>> ax2 = fig.add_subplot(122)  # right side
    >>> ascent = misc.ascent()
    >>> result = ndimage.minimum_filter(ascent, size=20)
    >>> ax1.imshow(ascent)
    >>> ax2.imshow(result)
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [38229 38234])
                    ("size" variable nil (reparse-symbol function_parameters) [38236 38240])
                    ("footprint" variable nil (reparse-symbol function_parameters) [38247 38256])
                    ("output" variable nil (reparse-symbol function_parameters) [38263 38269])
                    ("mode" variable nil (reparse-symbol function_parameters) [38295 38299])
                    ("cval" variable nil (reparse-symbol function_parameters) [38311 38315])
                    ("origin" variable nil (reparse-symbol function_parameters) [38321 38327]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [38199 39203])
            ("maximum_filter" function
               (:documentation "Calculate a multi-dimensional maximum filter.

    Parameters
    ----------
    %(input)s
    %(size_foot)s
    %(output)s
    %(mode_multiple)s
    %(cval)s
    %(origin)s

    Returns
    -------
    maximum_filter : ndarray
        Filtered array. Has the same shape as `input`.

    Examples
    --------
    >>> from scipy import ndimage, misc
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> plt.gray()  # show the filtered result in grayscale
    >>> ax1 = fig.add_subplot(121)  # left side
    >>> ax2 = fig.add_subplot(122)  # right side
    >>> ascent = misc.ascent()
    >>> result = ndimage.maximum_filter(ascent, size=20)
    >>> ax1.imshow(ascent)
    >>> ax2.imshow(result)
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [39235 39240])
                    ("size" variable nil (reparse-symbol function_parameters) [39242 39246])
                    ("footprint" variable nil (reparse-symbol function_parameters) [39253 39262])
                    ("output" variable nil (reparse-symbol function_parameters) [39269 39275])
                    ("mode" variable nil (reparse-symbol function_parameters) [39301 39305])
                    ("cval" variable nil (reparse-symbol function_parameters) [39317 39321])
                    ("origin" variable nil (reparse-symbol function_parameters) [39327 39333]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [39205 40209])
            ("_rank_filter" function
               (:decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [40239 40244])
                    ("rank" variable nil (reparse-symbol function_parameters) [40246 40250])
                    ("size" variable nil (reparse-symbol function_parameters) [40252 40256])
                    ("footprint" variable nil (reparse-symbol function_parameters) [40263 40272])
                    ("output" variable nil (reparse-symbol function_parameters) [40279 40285])
                    ("mode" variable nil (reparse-symbol function_parameters) [40309 40313])
                    ("cval" variable nil (reparse-symbol function_parameters) [40325 40329])
                    ("origin" variable nil (reparse-symbol function_parameters) [40335 40341])
                    ("operation" variable nil (reparse-symbol function_parameters) [40345 40354]))                  )
                nil [40211 42445])
            ("rank_filter" function
               (:documentation "Calculate a multi-dimensional rank filter.

    Parameters
    ----------
    %(input)s
    rank : int
        The rank parameter may be less then zero, i.e., rank = -1
        indicates the largest element.
    %(size_foot)s
    %(output)s
    %(mode)s
    %(cval)s
    %(origin)s

    Returns
    -------
    rank_filter : ndarray
        Filtered array. Has the same shape as `input`.

    Examples
    --------
    >>> from scipy import ndimage, misc
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> plt.gray()  # show the filtered result in grayscale
    >>> ax1 = fig.add_subplot(121)  # left side
    >>> ax2 = fig.add_subplot(122)  # right side
    >>> ascent = misc.ascent()
    >>> result = ndimage.rank_filter(ascent, rank=42, size=20)
    >>> ax1.imshow(ascent)
    >>> ax2.imshow(result)
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [42474 42479])
                    ("rank" variable nil (reparse-symbol function_parameters) [42481 42485])
                    ("size" variable nil (reparse-symbol function_parameters) [42487 42491])
                    ("footprint" variable nil (reparse-symbol function_parameters) [42498 42507])
                    ("output" variable nil (reparse-symbol function_parameters) [42514 42520])
                    ("mode" variable nil (reparse-symbol function_parameters) [42543 42547])
                    ("cval" variable nil (reparse-symbol function_parameters) [42559 42563])
                    ("origin" variable nil (reparse-symbol function_parameters) [42569 42575]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [42447 43555])
            ("median_filter" function
               (:documentation "
    Calculate a multidimensional median filter.

    Parameters
    ----------
    %(input)s
    %(size_foot)s
    %(output)s
    %(mode)s
    %(cval)s
    %(origin)s

    Returns
    -------
    median_filter : ndarray
        Filtered array. Has the same shape as `input`.

    Examples
    --------
    >>> from scipy import ndimage, misc
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> plt.gray()  # show the filtered result in grayscale
    >>> ax1 = fig.add_subplot(121)  # left side
    >>> ax2 = fig.add_subplot(122)  # right side
    >>> ascent = misc.ascent()
    >>> result = ndimage.median_filter(ascent, size=20)
    >>> ax1.imshow(ascent)
    >>> ax2.imshow(result)
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [43586 43591])
                    ("size" variable nil (reparse-symbol function_parameters) [43593 43597])
                    ("footprint" variable nil (reparse-symbol function_parameters) [43604 43613])
                    ("output" variable nil (reparse-symbol function_parameters) [43620 43626])
                    ("mode" variable nil (reparse-symbol function_parameters) [43651 43655])
                    ("cval" variable nil (reparse-symbol function_parameters) [43667 43671])
                    ("origin" variable nil (reparse-symbol function_parameters) [43677 43683]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [43557 44543])
            ("percentile_filter" function
               (:documentation "Calculate a multi-dimensional percentile filter.

    Parameters
    ----------
    %(input)s
    percentile : scalar
        The percentile parameter may be less then zero, i.e.,
        percentile = -20 equals percentile = 80
    %(size_foot)s
    %(output)s
    %(mode)s
    %(cval)s
    %(origin)s

    Returns
    -------
    percentile_filter : ndarray
        Filtered array. Has the same shape as `input`.

    Examples
    --------
    >>> from scipy import ndimage, misc
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> plt.gray()  # show the filtered result in grayscale
    >>> ax1 = fig.add_subplot(121)  # left side
    >>> ax2 = fig.add_subplot(122)  # right side
    >>> ascent = misc.ascent()
    >>> result = ndimage.percentile_filter(ascent, percentile=20, size=20)
    >>> ax1.imshow(ascent)
    >>> ax2.imshow(result)
    >>> plt.show()
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [44578 44583])
                    ("percentile" variable nil (reparse-symbol function_parameters) [44585 44595])
                    ("size" variable nil (reparse-symbol function_parameters) [44597 44601])
                    ("footprint" variable nil (reparse-symbol function_parameters) [44608 44617])
                    ("output" variable nil (reparse-symbol function_parameters) [44646 44652])
                    ("mode" variable nil (reparse-symbol function_parameters) [44659 44663])
                    ("cval" variable nil (reparse-symbol function_parameters) [44675 44679])
                    ("origin" variable nil (reparse-symbol function_parameters) [44685 44691]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [44545 45721])
            ("generic_filter1d" function
               (:documentation "Calculate a one-dimensional filter along the given axis.

    `generic_filter1d` iterates over the lines of the array, calling the
    given function at each line. The arguments of the line are the
    input line, and the output line. The input and output lines are 1D
    double arrays.  The input line is extended appropriately according
    to the filter size and origin. The output line must be modified
    in-place with the result.

    Parameters
    ----------
    %(input)s
    function : {callable, scipy.LowLevelCallable}
        Function to apply along given axis.
    filter_size : scalar
        Length of the filter.
    %(axis)s
    %(output)s
    %(mode)s
    %(cval)s
    %(origin)s
    %(extra_arguments)s
    %(extra_keywords)s

    Notes
    -----
    This function also accepts low-level callback functions with one of
    the following signatures and wrapped in `scipy.LowLevelCallable`:

    .. code:: c

       int function(double *input_line, npy_intp input_length,
                    double *output_line, npy_intp output_length,
                    void *user_data)
       int function(double *input_line, intptr_t input_length,
                    double *output_line, intptr_t output_length,
                    void *user_data)

    The calling function iterates over the lines of the input and output
    arrays, calling the callback function at each line. The current line
    is extended according to the border conditions set by the calling
    function, and the result is copied into the array that is passed
    through ``input_line``. The length of the input line (after extension)
    is passed through ``input_length``. The callback function should apply
    the filter and store the result in the array passed through
    ``output_line``. The length of the output line is passed through
    ``output_length``. ``user_data`` is the data pointer provided
    to `scipy.LowLevelCallable` as-is.

    The callback function must return an integer error status that is zero
    if something went wrong and one otherwise. If an error occurs, you should
    normally set the python error status with an informative message
    before returning, otherwise a default error message is set by the
    calling function.

    In addition, some other low-level function pointer specifications
    are accepted, but these are for backward compatibility only and should
    not be used in new code.

    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [45755 45760])
                    ("function" variable nil (reparse-symbol function_parameters) [45762 45770])
                    ("filter_size" variable nil (reparse-symbol function_parameters) [45772 45783])
                    ("axis" variable nil (reparse-symbol function_parameters) [45785 45789])
                    ("output" variable nil (reparse-symbol function_parameters) [45815 45821])
                    ("mode" variable nil (reparse-symbol function_parameters) [45828 45832])
                    ("cval" variable nil (reparse-symbol function_parameters) [45844 45848])
                    ("origin" variable nil (reparse-symbol function_parameters) [45854 45860])
                    ("extra_arguments" variable nil (reparse-symbol function_parameters) [45885 45900])
                    ("extra_keywords" variable nil (reparse-symbol function_parameters) [45905 45919]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [45723 49175])
            ("generic_filter" function
               (:documentation "Calculate a multi-dimensional filter using the given function.

    At each element the provided function is called. The input values
    within the filter footprint at that element are passed to the function
    as a 1D array of double values.

    Parameters
    ----------
    %(input)s
    function : {callable, scipy.LowLevelCallable}
        Function to apply at each element.
    %(size_foot)s
    %(output)s
    %(mode)s
    %(cval)s
    %(origin)s
    %(extra_arguments)s
    %(extra_keywords)s

    Notes
    -----
    This function also accepts low-level callback functions with one of
    the following signatures and wrapped in `scipy.LowLevelCallable`:

    .. code:: c

       int callback(double *buffer, npy_intp filter_size,
                    double *return_value, void *user_data)
       int callback(double *buffer, intptr_t filter_size,
                    double *return_value, void *user_data)

    The calling function iterates over the elements of the input and
    output arrays, calling the callback function at each element. The
    elements within the footprint of the filter at the current element are
    passed through the ``buffer`` parameter, and the number of elements
    within the footprint through ``filter_size``. The calculated value is
    returned in ``return_value``. ``user_data`` is the data pointer provided
    to `scipy.LowLevelCallable` as-is.

    The callback function must return an integer error status that is zero
    if something went wrong and one otherwise. If an error occurs, you should
    normally set the python error status with an informative message
    before returning, otherwise a default error message is set by the
    calling function.

    In addition, some other low-level function pointer specifications
    are accepted, but these are for backward compatibility only and should
    not be used in new code.

    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [49207 49212])
                    ("function" variable nil (reparse-symbol function_parameters) [49214 49222])
                    ("size" variable nil (reparse-symbol function_parameters) [49224 49228])
                    ("footprint" variable nil (reparse-symbol function_parameters) [49235 49244])
                    ("output" variable nil (reparse-symbol function_parameters) [49270 49276])
                    ("mode" variable nil (reparse-symbol function_parameters) [49283 49287])
                    ("cval" variable nil (reparse-symbol function_parameters) [49299 49303])
                    ("origin" variable nil (reparse-symbol function_parameters) [49309 49315])
                    ("extra_arguments" variable nil (reparse-symbol function_parameters) [49338 49353])
                    ("extra_keywords" variable nil (reparse-symbol function_parameters) [49358 49372]))                  
                :decorators 
                  ( ("docfiller" function (:type "decorator") nil nil))                  )
                nil [49177 52521]))          
      :file "filters.py"
      :pointmax 52521
      :fsize 52520
      :lastmodtime '(23206 34016 217686 0)
      :unmatched-syntax '((FROM 1560 . 1564) (PERIOD 1565 . 1566) (FROM 1534 . 1538) (PERIOD 1539 . 1540)))
    (semanticdb-table "semanticdb-table"
      :major-mode python-mode
      :tags 
        '( ("__future__" include nil nil [1443 1507])
            ("numpy" include nil nil [1509 1521])
            ("scipy._lib.six" include nil nil [1523 1562])
            ("_extend_mode_to_code" function
               (:documentation "Convert an extension mode to the corresponding integer code.
    "
                :arguments 
                  ( ("mode" variable nil (reparse-symbol function_parameters) [1590 1594]))                  )
                nil [1565 1961])
            ("_normalize_sequence" function
               (:documentation "If input is a scalar, create a sequence of length equal to the
    rank by duplicating the input. If input is a sequence,
    check if its length is equal to the length of array.
    "
                :arguments 
                  ( ("input" variable nil (reparse-symbol function_parameters) [1987 1992])
                    ("rank" variable nil (reparse-symbol function_parameters) [1994 1998])
                    ("array_type" variable nil (reparse-symbol function_parameters) [2000 2010]))                  )
                nil [1963 2555])
            ("_get_output" function (:arguments 
              ( ("output" variable nil (reparse-symbol function_parameters) [2573 2579])
                ("input" variable nil (reparse-symbol function_parameters) [2581 2586])
                ("shape" variable nil (reparse-symbol function_parameters) [2588 2593]))              ) nil [2557 3236])
            ("_check_axis" function (:arguments 
              ( ("axis" variable nil (reparse-symbol function_parameters) [3254 3258])
                ("rank" variable nil (reparse-symbol function_parameters) [3260 3264]))              ) nil [3238 3395]))          
      :file "_ni_support.py"
      :pointmax 3395
      :fsize 3394
      :lastmodtime '(23206 34016 217686 0)
      :unmatched-syntax nil))
  :file "!home!dsparch!.local!lib!python2.7!site-packages!scipy!ndimage!semantic.cache"
  :semantic-tag-version "2.0"
  :semanticdb-version "2.2")
